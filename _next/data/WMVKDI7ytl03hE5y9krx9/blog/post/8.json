{"pageProps":{"post":{"slug":"8","id":8,"title":"포스트 8: 유효한 상태만 표현하는 타입을 지향하기","date":"2023-02-07","tags":["Typescript","Javascript"],"summary":"효과적으로 타입을 설계하려면 유효한 상태만 표현하는 타입을 지향해야 합니다.","content":"<h1>아이템 28: 유효한 상태만 표현하는 타입을 지향하기</h1>\n<p>타입을 잘 설계하면 코드는 직관적으로 작성할 수 있다.</p>\n<p><code>효과적으로 타입을 설계하려면</code>, 유효한 상태만 표현할 수 있는 타입을 만들어 내는 것이 가장 중요하다.</p>\n<p>아이템 28은 이러한 관점에서 타입 설계가 잘못된 상황을 알아보고, 예제를 통해 잘못된 설계를 바로잡아 볼 것이다.</p>\n<hr>\n<p>웹 앱을 만든다고 가정해 보자.</p>\n<p>앱에서 페이지를 선택하면, 페이지의 내용을 로드하고 화면에 표시한다. 페이지의 상태는 다음처럼 설계했다.</p>\n<pre><code>interface State {\n  pageText: string;\n  isLoading: boolean;\n  error?: string;\n}\n</code></pre>\n<p>페이지를 그리는 renderPage 함수를 작성할 때는 상태 객체의 필드를 전부 고려해서 상태 표시를 분기해야 한다.</p>\n<pre><code>function renderPage(state: State) {\n  if(state.error) {  // 에러가 있다면\n    return `Error! Unable to load ${currentPage}: ${state.error}`\n  } else if(state.isLoading) {  // 로딩중이라면\n    return `Loading ${currentPage}...`\n  }  // 그 외\n  return `&#x3C;h1>${currentPage}&#x3C;/h1>\\n${state.pageText}`\n}\n</code></pre>\n<p>코드를 살펴보면 분기 조건이 명확히 분리되어 있지 않다는 것을 알 수 있다.</p>\n<p><code>isLoading이 true이고 동시에 error 값이 존재하면</code> 로딩 중인 상태인지 오류가 발생한 상태인지 명확히 구분할 수 없다. 필요한 정보가 부족하기 때문이다.</p>\n<hr>\n<p>한편 페이지를 전환하는 changePage 함수는 다음과 같다.</p>\n<pre><code>async function changePage(state: State, newPage: string) {\n  state.isLoading = true;\n  try {\n    const res = await fetch(getUrlForPage(newPage))\n    if(!res.ok) {\n      throw new Error(`Unable to load ${newPage}: ${res.statusText}`)\n    }\n\n    const text = await res.text()\n    state.isLoading = false\n    state.pageText = text\n  } catch(e) {\n    state.error = '' + e\n  }\n}\n</code></pre>\n<p>changePage에는 많은 문제점이 있다. 몇 가지 정리해 보면 다음과 같다.</p>\n<ul>\n<li>오류가 발생했을 때 state.isLoading을 false로 설정하는 로직이 빠져있다.</li>\n<li>state.error를 초기화하지 않았기 때문에, 페이지 전환 중에 로딩 메시지 대신 과거의 오류 메시지를 보여주게 된다.</li>\n<li>페이지 로딩 중에 사용자가 페이지를 바꿔 버리면 어떤 일이 벌어질지 예상하기 어렵다. 새 페이지에 오류가 뜨거나, 응답이 오는 순서에 따라 두 번째 페이지가 아닌 첫 번째 페이지로 전환될 수도 있다.</li>\n</ul>\n<p>문제는 바로 상태 값의 두 가지 속성이 동시에 정보가 부족하거나(요청이 실패한 것인지 여전히 로딩 중인지 알 수 없다), 두 가지 속성이 충돌(오류이면서 동시에 로딩 중일 수 있다)할 수 있다는 것이다.</p>\n<p><code>State 타입은 isLoading이 true이거나 동시에 error 값이 설정되는 무효한 상태를 허용한다.</code></p>\n<p>무효한 상태가 존재하면 render()와 changePage() 둘 다 제대로 구현할 수 없게 된다.</p>\n<hr>\n<p>다음은 애플리케이션의 상태를 좀 더 제대로 표현한 방법이다.</p>\n<p>여기서는 <code>네트워크 요청 과정 각각의 상태(앞서 isLoading과 error)를 명시적으로 모델링하는</code> 태그된 유니온이 사용되었다.</p>\n<pre><code>interface ReqPending {\n  state: 'pending';\n}\ninterface ReqError {\n  state: 'error';\n  error: string;\n}\ninterface ReqSuccess {\n  state: 'ok';\n  pageText: string;\n}\ntype ReqState = ReqPending | ReqError | ReqSuccess\n\ninterface State {\n  currentPage: string;\n  requests: { [page: string]: ReqState }\n}\n</code></pre>\n<p>아래의 예제는 코드 길이가 서너 배 길어지긴 했지만, 무효한 상태를 허용하지 않도록 크게 개선되었다.</p>\n<p>현재 페이지는 발생하는 모든 요청의 상태로서, 명시적으로 모델링되었다.</p>\n<p>그 결과로 개선된 renderPage와 changePage 함수는 쉽게 구현할 수 있다.</p>\n<pre><code>function renderPage(state: State) {\n  const { currentPage } = state;\n  const requestState = state.requests[currentPage];  // 현재 페이지의 request 상태를 담는다.\n\n  switch(requestState.state) {\n    case 'pending':\n      return `Loading ${currentPage}`;\n    case 'error':\n      return `Error! Unable to load ${currentPage}: ${requestState.error}`;\n    case 'ok':\n      return `&#x3C;h1>${currentPage}&#x3C;/h1>\\n${requestState.pageText}`;\n  }\n}\n\nasync function changePage(state: State, newPage: string) {\n  state.requests[newPage] = { state: 'pending' };\n  state.currentPage = newPage;\n  try {\n    const res = await fetch(getUrlForPage(newPage));\n    if(!res.ok) {\n      throw new Error(`Unable to load ${newPage}: ${res.statusText}`);\n    }\n    const pageText = await res.text();\n    state.requests[newPage] = { state: 'ok', pageText };\n  } catch(e) {\n    state.requests[newPage] = { state: 'error', error: '' + e};\n  }\n}\n</code></pre>\n<p>이제 <code>renderPage</code>와 <code>changePage</code>의 모호함은 완전히 사라졌다.</p>\n<p>현재 페이지가 무엇인지 명확하며, 모든 요청은 정확히 하나의 상태로 맞아 떨어진다. 요청이 진행 중인 상태에서 사용자가 페이지를 변경 하더라도 문제가 없다. 무의미한 요청이 실행되긴 하겠지만 UI에는 영향을 미치지 않는다.</p>\n<hr>\n<p>추락한 비행기인 에어버스 330 사례를 잠깐 보자. 에어버스는 전자 조종식 항공기로, 조종사의 제어가 물리적으로 비행 장치에 전달되기 전에 컴퓨터 시스템을 거치게 된다. 추락한 주요 원인은 잘못된 상태 설계였다.</p>\n<p>조종석에는 기장과 부기장을 위한 분리된 제어 세트가 있다. 사이드 스틱을 뒤로 당기면 비행기가 올라가고, 앞으로 밀면 아래로 내려가는 방식이다.</p>\n<p>에어버스 330은 두 개의 사이드 스틱이 독립적으로 움직이는 이중 입력 모드 시스템을 사용했다. 타입스크립트로 이중 입력 모드 상태를 모델링해 보면 다음과 같다.</p>\n<pre><code>/** 각 사이드 스틱의 각도, 0 = 중립, + = 앞으로 */\ninterface CockpitControls {\n  leftSideStick: number;\n  rightSideStick: number;\n}\n</code></pre>\n<p>이 데이터 구조가 주어진 상태에서 현재 스틱의 설정을 계산하는 <code>getStickSetting</code> 함수를 작성한다고 가정해 보자. 일단 기장(왼쪽 스틱)이 제어하고 있다고 가정하면 다음처럼 구현할 수 있다.</p>\n<pre><code>function getStickSetting(controls: CockpitControls) {\n  return controls.leftSideStick;\n}\n</code></pre>\n<p>부기장(오른쪽 스틱)이 제어하고 있는 상태라면 기장의 스틱 상태는 중립일 것이다. 결과적으로 기장이든 부기장이든 둘 중 하나의 스틱 값 중에서 중립이 아닌 값을 사용해야 한다.</p>\n<pre><code>function getStickSetting(controls: CockpitControls) {\n  const { leftSideStick, rightSideStick } = controls;\n  if(leftSideStick === 0) {\n    return rightSideStick;\n  }\n  return leftSideStick;\n}\n</code></pre>\n<p>그러나 이 코드엔 문제가 있다. 왼쪽 스틱의 로직과 동일하게 오른쪽 스틱이 중립일 때 왼쪽 스틱 값을 사용해야 한다. 그러므로 오른쪽 스틱에 대한 체크를 추가해야 한다.</p>\n<pre><code>function getStickSetting(controls: CockpitControls) {\n  const { leftSideStick, rightSideStick } = controls;\n  if(leftSideStick === 0) {\n    return rightSideStick;\n  } else if(rightSideStick === 0) {\n    return leftSideStick;\n  }\n  // ???\n}\n</code></pre>\n<p>두 스틱이 모두 중립이 아닌 경우를 고려해 보자. 다행히 두 스틱이 비슷한 값이라면 스틱의 각도를 평균해서 계산할 수 있다.</p>\n<pre><code>// 둘 다 중립이 아니지만, 각도가 비슷할 때\nfunction getStickSetting(controls: CockpitControls) {\n  const { leftSideStick, rightSideStick } = controls;\n  if(leftSideStick === 0) {\n    return rightSideStick;\n  } else if(rightSideStick === 0) {\n    return leftSideStick;\n  }\n  if(Math.abs(leftSideStick - rightSideStick) &#x3C; 5) {\n    return (leftSideStick + rightSideStick) / 2;\n  }\n  // ???\n}\n</code></pre>\n<p>그러나 두 스틱의 각도가 매우 다른 경우는 해결하기 어렵다. 그럼에도 비행 중이기 스틱의 각도는 어떻게든 설정되어야 한다.</p>\n<hr>\n<p>한편, 에어버스의 사고 당시 로직은 이러했다.</p>\n<pre><code>function getStickSetting(controls: CockpitControls) {\n  return (controls.leftSideStick + controls.rightSideStick) / 2;\n}\n</code></pre>\n<p>기장이 스틱을 앞으로 밀었음에도 부기장이 뒤로 당기고 있었기에 평균값에는 변화가 없었던 것이다. 따라서 에어버스는 아무것도 하지 않은 것이 된다.</p>\n<p>이 모든 이야기의 요점은, 주어진 입력으로 <code>getStickSetting</code>을 구현하는 제대로 된 방법이 없다는 것이다.</p>\n<p><code>getStickSetting은 실패할 수밖에 없었다.</code></p>\n<p>대부분의 비행기는 두 개의 스틱이 기계적으로 연결되어 있다. 부기장이 뒤로 당기면, 기장의 스틱도 뒤로 당겨진다.</p>\n<p>기계적으로 연결된 스틱의 상태는 표현이 간단하다.</p>\n<pre><code>interface CockpitControls {\n  stickAngle: number;\n}\n</code></pre>\n<p>사실 getStickSetting 함수는 전혀 필요 없었다.</p>\n<p>타입을 설계할 때는 어떤 값들을 포함하고 어떤 값들을 제외할지 신중하게 생각해야 한다.</p>\n<p>유효한 상태를 표현하는 값만 허용한다면 코드를 작성하기 쉬워지고 타입 체크가 용이해진다.</p>\n<p>유효한 상태만 허용하는 것은 매우 일반적인 원칙이다.</p>\n<hr>\n<ul>\n<li>유효한 상태와 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고 오류를 유발하게 된다.</li>\n<li>유효한 상태만 표현하는 타입을 지향해야 한다. 코드가 길어지거나 표현하기 어렵지만 결국은 시간을 절약하고 고통을 줄일 수 있다.</li>\n</ul>\n"}},"__N_SSG":true}