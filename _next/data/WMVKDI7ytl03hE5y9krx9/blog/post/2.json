{"pageProps":{"post":{"slug":"2","id":2,"title":"아이템 24: 일관성 있는 별칭 사용하기","date":"2023-02-11","tags":["Typescript","Javascript"],"summary":"일관성 있는 별칭을 사용해야 합니다.","content":"<h1>아이템 24: 일관성 있는 별칭 사용하기</h1>\n<pre><code>const borough = {\n  name: 'Brooklyn',\n  location: [40.688, -73.979]\n};\nconst loc = borough.location;\n</code></pre>\n<p>위 코드에서 <code>borough.location</code> 배열에 <code>loc</code> 이라는 <code>별칭(alias)</code>을 만들었다.</p>\n<p>별칭의 값을 변경하면 원래 속성값에서도 변경된다.</p>\n<p>허나, 별칭을 남발해서 사용하면 제어 흐름을 분석하기 어렵다.</p>\n<p>타입스크립트에서도 별칭을 신중하게 사용해야 한다.</p>\n<p>다각형을 표현하는 자료구조를 가정해 보자.</p>\n<pre><code>interface Coordinate {\n  x: number;\n  y: number;\n}\n\ninterface BoundingBox {\n  x: [number, number];\n  y: [number, number];\n}\n\ninterface Polygon {\n  exterior: Coordinate[];\n  holes: Coordinate[][];\n  bbox?: BoundingBox;\n}\n</code></pre>\n<p>다각형의 기하학적 구조는 <code>exterior</code>와 <code>holes</code> 속성으로 정의된다. <code>bbox</code>는 필수가 아닌 최적화 속성이다.</p>\n<p><code>bbox</code> 속성을 사용하면 어떤 점이 다각형에 포함되는지 빠르게 체크할 수 있다.</p>\n<pre><code>function isPointInPolygon(polygon: Polygon, pt: Coordinate) {\n  if(polygon.bbox) {\n    if(pt.x &#x3C; polygon.bbox.x[0] || pt.x > polygon.bbox.x[1] ||\n      pt.y &#x3C; polygon.bbox.y[0] || pt.y > polygon.bbox.y[1]) {\n      return false;\n    }\n  }\n\n  // ...\n}\n</code></pre>\n<p>위 코드는 잘 작동하지만(타입체크도 통과) 반복되는 부분이 존재한다.</p>\n<p><code>polygon.bbox</code>는 3줄에 걸쳐 5번이나 등장한다. 아래는 중복을 줄이기 위해 임시 변수를 뽑아낸 모습이다.</p>\n<pre><code>function isPointInPolygon(polygon: Polygon, pt: Coordinate) {\n  const box = polygon.bbox;\n  if(polygon.bbox) {\n    if(pt.x &#x3C; box.x[0] || pt.x > box.x[1] || // box 객체가 'undefined'일 수 있습니다.\n      pt.y &#x3C; box.y[0] || pt.y > box.y[1]) {\n      return false;\n    }\n  }\n\n  // ...\n}\n</code></pre>\n<p>(strictNullChecks를 화성화했다고 가정)</p>\n<p>위 코드는 동작하지만 편집기에서 오류로 표시된다. <code>polygon.bbox</code>라는 별도의  <code>box</code>라는 별칭을 만들었고, 첫 번째에서 잘 동작했던 제어 흐름 분석을 방해했기 때문이다.</p>\n<p><code>polygon.bbox</code>는 타입이 <code>BoundingBox | undefined</code>인데 속성 체크가 <code>polygon.bbox</code>의 타입을 정제했지만 <code>box</code>는 끄렇지 않았기 때문에 오류가 발생한다.</p>\n<p>이러한 오류는 <code>별칭은 일관성 있게 사용한다</code>는 기본 원칙(golden rule)을 지키면 방지할 수 있다.</p>\n<pre><code>function isPointInPolygon(polygon: Polygon, pt: Coordinate) {\n  const box = polygon.bbox;\n  if(box) {\n    if(pt.x &#x3C; box.x[0] || pt.x > box.x[1] ||\n      pt.y &#x3C; box.y[0] || pt.y > box.y[1]) {\n      return false;\n    }\n  }\n\n  // ...\n}\n</code></pre>\n<hr>\n<p>그러나 객체 비구조화를 이용할 때는 두 가지를 주의해야 한다.</p>\n<ul>\n<li>전체 <code>bbox</code> 속성이 아니라 <code>x</code>와 <code>y</code>가 선택적 속성일 경우에 속성 체크가 더 필요하다. 따라서 타입의 경계에 <code>null</code> 값을 추가하는 것이 좋다(아이템 31).</li>\n<li><code>bbox</code>에는 선택적 속성이 적합했지만 <code>holes</code>는 그렇지 않다. <code>holes</code>가 선택적이라면, 값이 없거나 빈 배열이었을 것이다. 차이가 없는데 이름을 구별한것이다. 빈 배열은 <code>holes 없음</code>을 나타내는 좋은 방법이다.</li>\n</ul>\n<p>별칭은 타입 체커뿐만 아니라 런타임에도 혼동을 야기할 수 있다.</p>\n<pre><code>const { bbox } = polygon;\nif(!bbox) {\n  calculatePolygonBbox(polygon);  // polygon.bbox가 채워진다.\n  // 이제 polygon.bbox와 bbox는 다른 값을 참조한다.\n}\n</code></pre>\n<p>타입스크립트의 제어 흐름 분석은 지역 변수에는 꽤 잘 작동한다. 그러나 객체 속성에서는 주의해야 한다.</p>\n<pre><code>function fn(p: Polygon) { /* ... */ }\n\npolygon.bbox. // 타입이 BoundingBox | undefined\nif(polygon.bbox) {\n  polygon.bbox. // 타입이 BoundingBox\n  fn(polygon);\n  polygon.bbox. // 타입이 BoundingBox\n}\n</code></pre>\n<p><code>fn(polygon)</code> 호출은 <code>polygon.bbox</code>를 제거할 가능성이 있으므로 타입을 <code>BoundingBox | undefined</code>로 되돌리는 것이 안절한 것이다. 그러나 함수를 호출할 때마다 속성체크를 반복해야 하기 때문에 좋지 않다. 그래서 타입스크립트는 함수가 타입 정제를 무효화하지 않느다고 가정한다. 그러나 실제로는 무효화될 가능성이 있다.</p>\n<p><code>polygon.bbox</code>로 사용하는 대신 <code>bbox</code> 지역 변수로 뽑아내서 사용하면 <code>bbox</code>의 타입은 정확히 유지되지만, <code>polygon.bbox</code>의 값과 같게 유지되지 않을 수 있다.</p>\n<h3>요약</h3>\n<ul>\n<li>별칭은 타입스크립트가 타입을 좁히는 것을 방해한다. 따라서 변수에 별칭을 사용할 때는 일관되게 사용해야 한다.</li>\n<li>비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋다.</li>\n<li>함수 호출이 객체 속성의 타입 정제를 무효화할 수 있다는 점을 주의해야 한다. 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.</li>\n</ul>\n"}},"__N_SSG":true}