<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>킹왕짱바다 - 블로그</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="블로그. 공부 내용, 일상을 자유롭게 기록."/><meta name="keyword" content="장현광, 킹왕짱바다, 웹, 개발, 개발자, 개발자 블로그, 일상, 잡담, 공부, 취미, 기록"/><meta name="robots" content="index, follow"/><meta property="og:type" content="website"/><meta property="og:title" content="킹왕짱바다 - 블로그"/><meta property="og:description" content="블로그. 자유롭고 잡다한 기록들."/><meta property="og:image" content="../assets/images/me_1.png"/><meta property="og:image:width" content="630"/><meta property="og:image:height" content="630"/><meta property="og:url" content="/blog/1"/><meta property="twitter:card" content="summary"/><meta property="twitter:title" content="킹왕짱바다 - 블로그"/><meta property="twitter:description" content="블로그. 자유롭고 잡다한 기록들."/><meta property="twitter:image" content="../assets/images/me_1.png"/><meta name="next-head-count" content="17"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><link rel="preload" href="/https://king-bada.dev/_next/static/css/52f7012b3b79f2fb.css" as="style"/><link rel="stylesheet" href="/https://king-bada.dev/_next/static/css/52f7012b3b79f2fb.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/https://king-bada.dev/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/https://king-bada.dev/_next/static/chunks/webpack-bb1962c799383232.js" defer=""></script><script src="/https://king-bada.dev/_next/static/chunks/framework-df7ee52d1c137bc3.js" defer=""></script><script src="/https://king-bada.dev/_next/static/chunks/main-d1841ffbf0c00f48.js" defer=""></script><script src="/https://king-bada.dev/_next/static/chunks/pages/_app-0101e8f78d66ce0d.js" defer=""></script><script src="/https://king-bada.dev/_next/static/chunks/453-875485057ff901bb.js" defer=""></script><script src="/https://king-bada.dev/_next/static/chunks/830-744088323c11a854.js" defer=""></script><script src="/https://king-bada.dev/_next/static/chunks/pages/blog/post/%5BrealSlug%5D-305dede71629126c.js" defer=""></script><script src="/https://king-bada.dev/_next/static/Vn2MyYZs1JmGR9bFd08uD/_buildManifest.js" defer=""></script><script src="/https://king-bada.dev/_next/static/Vn2MyYZs1JmGR9bFd08uD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="wrapper"><div class="my-8 p-16 bg-white border-4 border-blue-500 rounded font-oswald font-bold shadow-normal"><h1 class="mt-0 mb-4 text-7xl text-blue-500 font-normal">아이템 28: 유효한 상태만 표현하는 타입을 지향하기</h1><span class="block mb-12 text-base text-blue-500">2023-02-07</span><ul class="flex gap-2 m-0 p-0"><li class=" inline-flex justify-center items-center py-1 px-2 bg-blue-300 rounded font-notoSans font-normal text-xs cursor-pointer hover:bg-blue-400 ">Typescript</li><li class=" inline-flex justify-center items-center py-1 px-2 bg-blue-300 rounded font-notoSans font-normal text-xs cursor-pointer hover:bg-blue-400 ">Javascript</li></ul></div></header><nav class="wrapper flex justify-between items-center sticky top-[-1px] z-50 w-full mx-auto py-4 px-6 bg-blue-500 text-white transition-all duration-700 east-in-out"><a class="text-inherit no-underline hover:text-orange-400" href="/">바다</a><ul></ul><a class="text-inherit no-underline py-2 px-6 bg-orange-400 hover:bg-orange-400/80 rounded-full" href="/info/">Contact</a></nav><div class="wrapper"><main class="py-8"><article class="post-container"><h1>아이템 28: 유효한 상태만 표현하는 타입을 지향하기</h1>
<p>타입을 잘 설계하면 코드는 직관적으로 작성할 수 있다.</p>
<p><code>효과적으로 타입을 설계하려면</code>, 유효한 상태만 표현할 수 있는 타입을 만들어 내는 것이 가장 중요하다.</p>
<p>아이템 28은 이러한 관점에서 타입 설계가 잘못된 상황을 알아보고, 예제를 통해 잘못된 설계를 바로잡아 볼 것이다.</p>
<hr>
<p>웹 앱을 만든다고 가정해 보자.</p>
<p>앱에서 페이지를 선택하면, 페이지의 내용을 로드하고 화면에 표시한다. 페이지의 상태는 다음처럼 설계했다.</p>
<pre><code>interface State {
  pageText: string;
  isLoading: boolean;
  error?: string;
}
</code></pre>
<p>페이지를 그리는 renderPage 함수를 작성할 때는 상태 객체의 필드를 전부 고려해서 상태 표시를 분기해야 한다.</p>
<pre><code>function renderPage(state: State) {
  if(state.error) {  // 에러가 있다면
    return `Error! Unable to load ${currentPage}: ${state.error}`
  } else if(state.isLoading) {  // 로딩중이라면
    return `Loading ${currentPage}...`
  }  // 그 외
  return `&#x3C;h1>${currentPage}&#x3C;/h1>\n${state.pageText}`
}
</code></pre>
<p>코드를 살펴보면 분기 조건이 명확히 분리되어 있지 않다는 것을 알 수 있다.</p>
<p><code>isLoading이 true이고 동시에 error 값이 존재하면</code> 로딩 중인 상태인지 오류가 발생한 상태인지 명확히 구분할 수 없다. 필요한 정보가 부족하기 때문이다.</p>
<hr>
<p>한편 페이지를 전환하는 changePage 함수는 다음과 같다.</p>
<pre><code>async function changePage(state: State, newPage: string) {
  state.isLoading = true;
  try {
    const res = await fetch(getUrlForPage(newPage))
    if(!res.ok) {
      throw new Error(`Unable to load ${newPage}: ${res.statusText}`)
    }

    const text = await res.text()
    state.isLoading = false
    state.pageText = text
  } catch(e) {
    state.error = '' + e
  }
}
</code></pre>
<p>changePage에는 많은 문제점이 있다. 몇 가지 정리해 보면 다음과 같다.</p>
<ul>
<li>오류가 발생했을 때 state.isLoading을 false로 설정하는 로직이 빠져있다.</li>
<li>state.error를 초기화하지 않았기 때문에, 페이지 전환 중에 로딩 메시지 대신 과거의 오류 메시지를 보여주게 된다.</li>
<li>페이지 로딩 중에 사용자가 페이지를 바꿔 버리면 어떤 일이 벌어질지 예상하기 어렵다. 새 페이지에 오류가 뜨거나, 응답이 오는 순서에 따라 두 번째 페이지가 아닌 첫 번째 페이지로 전환될 수도 있다.</li>
</ul>
<p>문제는 바로 상태 값의 두 가지 속성이 동시에 정보가 부족하거나(요청이 실패한 것인지 여전히 로딩 중인지 알 수 없다), 두 가지 속성이 충돌(오류이면서 동시에 로딩 중일 수 있다)할 수 있다는 것이다.</p>
<p><code>State 타입은 isLoading이 true이거나 동시에 error 값이 설정되는 무효한 상태를 허용한다.</code></p>
<p>무효한 상태가 존재하면 render()와 changePage() 둘 다 제대로 구현할 수 없게 된다.</p>
<hr>
<p>다음은 애플리케이션의 상태를 좀 더 제대로 표현한 방법이다.</p>
<p>여기서는 <code>네트워크 요청 과정 각각의 상태(앞서 isLoading과 error)를 명시적으로 모델링하는</code> 태그된 유니온이 사용되었다.</p>
<pre><code>interface ReqPending {
  state: 'pending';
}
interface ReqError {
  state: 'error';
  error: string;
}
interface ReqSuccess {
  state: 'ok';
  pageText: string;
}
type ReqState = ReqPending | ReqError | ReqSuccess

interface State {
  currentPage: string;
  requests: { [page: string]: ReqState }
}
</code></pre>
<p>아래의 예제는 코드 길이가 서너 배 길어지긴 했지만, 무효한 상태를 허용하지 않도록 크게 개선되었다.</p>
<p>현재 페이지는 발생하는 모든 요청의 상태로서, 명시적으로 모델링되었다.</p>
<p>그 결과로 개선된 renderPage와 changePage 함수는 쉽게 구현할 수 있다.</p>
<pre><code>function renderPage(state: State) {
  const { currentPage } = state;
  const requestState = state.requests[currentPage];  // 현재 페이지의 request 상태를 담는다.

  switch(requestState.state) {
    case 'pending':
      return `Loading ${currentPage}`;
    case 'error':
      return `Error! Unable to load ${currentPage}: ${requestState.error}`;
    case 'ok':
      return `&#x3C;h1>${currentPage}&#x3C;/h1>\n${requestState.pageText}`;
  }
}

async function changePage(state: State, newPage: string) {
  state.requests[newPage] = { state: 'pending' };
  state.currentPage = newPage;
  try {
    const res = await fetch(getUrlForPage(newPage));
    if(!res.ok) {
      throw new Error(`Unable to load ${newPage}: ${res.statusText}`);
    }
    const pageText = await res.text();
    state.requests[newPage] = { state: 'ok', pageText };
  } catch(e) {
    state.requests[newPage] = { state: 'error', error: '' + e};
  }
}
</code></pre>
<p>이제 <code>renderPage</code>와 <code>changePage</code>의 모호함은 완전히 사라졌다.</p>
<p>현재 페이지가 무엇인지 명확하며, 모든 요청은 정확히 하나의 상태로 맞아 떨어진다. 요청이 진행 중인 상태에서 사용자가 페이지를 변경 하더라도 문제가 없다. 무의미한 요청이 실행되긴 하겠지만 UI에는 영향을 미치지 않는다.</p>
<hr>
<p>추락한 비행기인 에어버스 330 사례를 잠깐 보자. 에어버스는 전자 조종식 항공기로, 조종사의 제어가 물리적으로 비행 장치에 전달되기 전에 컴퓨터 시스템을 거치게 된다. 추락한 주요 원인은 잘못된 상태 설계였다.</p>
<p>조종석에는 기장과 부기장을 위한 분리된 제어 세트가 있다. 사이드 스틱을 뒤로 당기면 비행기가 올라가고, 앞으로 밀면 아래로 내려가는 방식이다.</p>
<p>에어버스 330은 두 개의 사이드 스틱이 독립적으로 움직이는 이중 입력 모드 시스템을 사용했다. 타입스크립트로 이중 입력 모드 상태를 모델링해 보면 다음과 같다.</p>
<pre><code>/** 각 사이드 스틱의 각도, 0 = 중립, + = 앞으로 */
interface CockpitControls {
  leftSideStick: number;
  rightSideStick: number;
}
</code></pre>
<p>이 데이터 구조가 주어진 상태에서 현재 스틱의 설정을 계산하는 <code>getStickSetting</code> 함수를 작성한다고 가정해 보자. 일단 기장(왼쪽 스틱)이 제어하고 있다고 가정하면 다음처럼 구현할 수 있다.</p>
<pre><code>function getStickSetting(controls: CockpitControls) {
  return controls.leftSideStick;
}
</code></pre>
<p>부기장(오른쪽 스틱)이 제어하고 있는 상태라면 기장의 스틱 상태는 중립일 것이다. 결과적으로 기장이든 부기장이든 둘 중 하나의 스틱 값 중에서 중립이 아닌 값을 사용해야 한다.</p>
<pre><code>function getStickSetting(controls: CockpitControls) {
  const { leftSideStick, rightSideStick } = controls;
  if(leftSideStick === 0) {
    return rightSideStick;
  }
  return leftSideStick;
}
</code></pre>
<p>그러나 이 코드엔 문제가 있다. 왼쪽 스틱의 로직과 동일하게 오른쪽 스틱이 중립일 때 왼쪽 스틱 값을 사용해야 한다. 그러므로 오른쪽 스틱에 대한 체크를 추가해야 한다.</p>
<pre><code>function getStickSetting(controls: CockpitControls) {
  const { leftSideStick, rightSideStick } = controls;
  if(leftSideStick === 0) {
    return rightSideStick;
  } else if(rightSideStick === 0) {
    return leftSideStick;
  }
  // ???
}
</code></pre>
<p>두 스틱이 모두 중립이 아닌 경우를 고려해 보자. 다행히 두 스틱이 비슷한 값이라면 스틱의 각도를 평균해서 계산할 수 있다.</p>
<pre><code>// 둘 다 중립이 아니지만, 각도가 비슷할 때
function getStickSetting(controls: CockpitControls) {
  const { leftSideStick, rightSideStick } = controls;
  if(leftSideStick === 0) {
    return rightSideStick;
  } else if(rightSideStick === 0) {
    return leftSideStick;
  }
  if(Math.abs(leftSideStick - rightSideStick) &#x3C; 5) {
    return (leftSideStick + rightSideStick) / 2;
  }
  // ???
}
</code></pre>
<p>그러나 두 스틱의 각도가 매우 다른 경우는 해결하기 어렵다. 그럼에도 비행 중이기 스틱의 각도는 어떻게든 설정되어야 한다.</p>
<hr>
<p>한편, 에어버스의 사고 당시 로직은 이러했다.</p>
<pre><code>function getStickSetting(controls: CockpitControls) {
  return (controls.leftSideStick + controls.rightSideStick) / 2;
}
</code></pre>
<p>기장이 스틱을 앞으로 밀었음에도 부기장이 뒤로 당기고 있었기에 평균값에는 변화가 없었던 것이다. 따라서 에어버스는 아무것도 하지 않은 것이 된다.</p>
<p>이 모든 이야기의 요점은, 주어진 입력으로 <code>getStickSetting</code>을 구현하는 제대로 된 방법이 없다는 것이다.</p>
<p><code>getStickSetting은 실패할 수밖에 없었다.</code></p>
<p>대부분의 비행기는 두 개의 스틱이 기계적으로 연결되어 있다. 부기장이 뒤로 당기면, 기장의 스틱도 뒤로 당겨진다.</p>
<p>기계적으로 연결된 스틱의 상태는 표현이 간단하다.</p>
<pre><code>interface CockpitControls {
  stickAngle: number;
}
</code></pre>
<p>사실 getStickSetting 함수는 전혀 필요 없었다.</p>
<p>타입을 설계할 때는 어떤 값들을 포함하고 어떤 값들을 제외할지 신중하게 생각해야 한다.</p>
<p>유효한 상태를 표현하는 값만 허용한다면 코드를 작성하기 쉬워지고 타입 체크가 용이해진다.</p>
<p>유효한 상태만 허용하는 것은 매우 일반적인 원칙이다.</p>
<hr>
<ul>
<li>유효한 상태와 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고 오류를 유발하게 된다.</li>
<li>유효한 상태만 표현하는 타입을 지향해야 한다. 코드가 길어지거나 표현하기 어렵지만 결국은 시간을 절약하고 고통을 줄일 수 있다.</li>
</ul>
</article></main></div><footer class="py-16 bg-slate-800"><div class="wrapper"><h1 class="mb-2 text-lg text-white font-bold italic">킹왕짱바다</h1><div class="flex flex-row text-white"><div class="flex flex-col w-16"><span class="flex justify-between"><span>이</span><span>름</span></span><span class="flex justify-between"><span>이</span><span>메</span><span>일</span></span></div><div class="flex flex-col mx-1"><span>:</span><span>:</span></div><div class="flex flex-col"><span>장현광</span><span>wkdgusrhkd@gmail.com</span></div></div><h2 class="mt-2 text-base text-white">© Created by King-Bada, 2023.</h2></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"1","id":1,"title":"아이템 28: 유효한 상태만 표현하는 타입을 지향하기","date":"2023-02-07","tags":["Typescript","Javascript"],"summary":"효과적으로 타입을 설계하려면 유효한 상태만 표현하는 타입을 지향해야 합니다.","content":"\u003ch1\u003e아이템 28: 유효한 상태만 표현하는 타입을 지향하기\u003c/h1\u003e\n\u003cp\u003e타입을 잘 설계하면 코드는 직관적으로 작성할 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003e효과적으로 타입을 설계하려면\u003c/code\u003e, 유효한 상태만 표현할 수 있는 타입을 만들어 내는 것이 가장 중요하다.\u003c/p\u003e\n\u003cp\u003e아이템 28은 이러한 관점에서 타입 설계가 잘못된 상황을 알아보고, 예제를 통해 잘못된 설계를 바로잡아 볼 것이다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e웹 앱을 만든다고 가정해 보자.\u003c/p\u003e\n\u003cp\u003e앱에서 페이지를 선택하면, 페이지의 내용을 로드하고 화면에 표시한다. 페이지의 상태는 다음처럼 설계했다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einterface State {\n  pageText: string;\n  isLoading: boolean;\n  error?: string;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e페이지를 그리는 renderPage 함수를 작성할 때는 상태 객체의 필드를 전부 고려해서 상태 표시를 분기해야 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction renderPage(state: State) {\n  if(state.error) {  // 에러가 있다면\n    return `Error! Unable to load ${currentPage}: ${state.error}`\n  } else if(state.isLoading) {  // 로딩중이라면\n    return `Loading ${currentPage}...`\n  }  // 그 외\n  return `\u0026#x3C;h1\u003e${currentPage}\u0026#x3C;/h1\u003e\\n${state.pageText}`\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e코드를 살펴보면 분기 조건이 명확히 분리되어 있지 않다는 것을 알 수 있다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eisLoading이 true이고 동시에 error 값이 존재하면\u003c/code\u003e 로딩 중인 상태인지 오류가 발생한 상태인지 명확히 구분할 수 없다. 필요한 정보가 부족하기 때문이다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e한편 페이지를 전환하는 changePage 함수는 다음과 같다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003easync function changePage(state: State, newPage: string) {\n  state.isLoading = true;\n  try {\n    const res = await fetch(getUrlForPage(newPage))\n    if(!res.ok) {\n      throw new Error(`Unable to load ${newPage}: ${res.statusText}`)\n    }\n\n    const text = await res.text()\n    state.isLoading = false\n    state.pageText = text\n  } catch(e) {\n    state.error = '' + e\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003echangePage에는 많은 문제점이 있다. 몇 가지 정리해 보면 다음과 같다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e오류가 발생했을 때 state.isLoading을 false로 설정하는 로직이 빠져있다.\u003c/li\u003e\n\u003cli\u003estate.error를 초기화하지 않았기 때문에, 페이지 전환 중에 로딩 메시지 대신 과거의 오류 메시지를 보여주게 된다.\u003c/li\u003e\n\u003cli\u003e페이지 로딩 중에 사용자가 페이지를 바꿔 버리면 어떤 일이 벌어질지 예상하기 어렵다. 새 페이지에 오류가 뜨거나, 응답이 오는 순서에 따라 두 번째 페이지가 아닌 첫 번째 페이지로 전환될 수도 있다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e문제는 바로 상태 값의 두 가지 속성이 동시에 정보가 부족하거나(요청이 실패한 것인지 여전히 로딩 중인지 알 수 없다), 두 가지 속성이 충돌(오류이면서 동시에 로딩 중일 수 있다)할 수 있다는 것이다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003eState 타입은 isLoading이 true이거나 동시에 error 값이 설정되는 무효한 상태를 허용한다.\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e무효한 상태가 존재하면 render()와 changePage() 둘 다 제대로 구현할 수 없게 된다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e다음은 애플리케이션의 상태를 좀 더 제대로 표현한 방법이다.\u003c/p\u003e\n\u003cp\u003e여기서는 \u003ccode\u003e네트워크 요청 과정 각각의 상태(앞서 isLoading과 error)를 명시적으로 모델링하는\u003c/code\u003e 태그된 유니온이 사용되었다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einterface ReqPending {\n  state: 'pending';\n}\ninterface ReqError {\n  state: 'error';\n  error: string;\n}\ninterface ReqSuccess {\n  state: 'ok';\n  pageText: string;\n}\ntype ReqState = ReqPending | ReqError | ReqSuccess\n\ninterface State {\n  currentPage: string;\n  requests: { [page: string]: ReqState }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e아래의 예제는 코드 길이가 서너 배 길어지긴 했지만, 무효한 상태를 허용하지 않도록 크게 개선되었다.\u003c/p\u003e\n\u003cp\u003e현재 페이지는 발생하는 모든 요청의 상태로서, 명시적으로 모델링되었다.\u003c/p\u003e\n\u003cp\u003e그 결과로 개선된 renderPage와 changePage 함수는 쉽게 구현할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction renderPage(state: State) {\n  const { currentPage } = state;\n  const requestState = state.requests[currentPage];  // 현재 페이지의 request 상태를 담는다.\n\n  switch(requestState.state) {\n    case 'pending':\n      return `Loading ${currentPage}`;\n    case 'error':\n      return `Error! Unable to load ${currentPage}: ${requestState.error}`;\n    case 'ok':\n      return `\u0026#x3C;h1\u003e${currentPage}\u0026#x3C;/h1\u003e\\n${requestState.pageText}`;\n  }\n}\n\nasync function changePage(state: State, newPage: string) {\n  state.requests[newPage] = { state: 'pending' };\n  state.currentPage = newPage;\n  try {\n    const res = await fetch(getUrlForPage(newPage));\n    if(!res.ok) {\n      throw new Error(`Unable to load ${newPage}: ${res.statusText}`);\n    }\n    const pageText = await res.text();\n    state.requests[newPage] = { state: 'ok', pageText };\n  } catch(e) {\n    state.requests[newPage] = { state: 'error', error: '' + e};\n  }\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이제 \u003ccode\u003erenderPage\u003c/code\u003e와 \u003ccode\u003echangePage\u003c/code\u003e의 모호함은 완전히 사라졌다.\u003c/p\u003e\n\u003cp\u003e현재 페이지가 무엇인지 명확하며, 모든 요청은 정확히 하나의 상태로 맞아 떨어진다. 요청이 진행 중인 상태에서 사용자가 페이지를 변경 하더라도 문제가 없다. 무의미한 요청이 실행되긴 하겠지만 UI에는 영향을 미치지 않는다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e추락한 비행기인 에어버스 330 사례를 잠깐 보자. 에어버스는 전자 조종식 항공기로, 조종사의 제어가 물리적으로 비행 장치에 전달되기 전에 컴퓨터 시스템을 거치게 된다. 추락한 주요 원인은 잘못된 상태 설계였다.\u003c/p\u003e\n\u003cp\u003e조종석에는 기장과 부기장을 위한 분리된 제어 세트가 있다. 사이드 스틱을 뒤로 당기면 비행기가 올라가고, 앞으로 밀면 아래로 내려가는 방식이다.\u003c/p\u003e\n\u003cp\u003e에어버스 330은 두 개의 사이드 스틱이 독립적으로 움직이는 이중 입력 모드 시스템을 사용했다. 타입스크립트로 이중 입력 모드 상태를 모델링해 보면 다음과 같다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e/** 각 사이드 스틱의 각도, 0 = 중립, + = 앞으로 */\ninterface CockpitControls {\n  leftSideStick: number;\n  rightSideStick: number;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e이 데이터 구조가 주어진 상태에서 현재 스틱의 설정을 계산하는 \u003ccode\u003egetStickSetting\u003c/code\u003e 함수를 작성한다고 가정해 보자. 일단 기장(왼쪽 스틱)이 제어하고 있다고 가정하면 다음처럼 구현할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction getStickSetting(controls: CockpitControls) {\n  return controls.leftSideStick;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e부기장(오른쪽 스틱)이 제어하고 있는 상태라면 기장의 스틱 상태는 중립일 것이다. 결과적으로 기장이든 부기장이든 둘 중 하나의 스틱 값 중에서 중립이 아닌 값을 사용해야 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction getStickSetting(controls: CockpitControls) {\n  const { leftSideStick, rightSideStick } = controls;\n  if(leftSideStick === 0) {\n    return rightSideStick;\n  }\n  return leftSideStick;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 이 코드엔 문제가 있다. 왼쪽 스틱의 로직과 동일하게 오른쪽 스틱이 중립일 때 왼쪽 스틱 값을 사용해야 한다. 그러므로 오른쪽 스틱에 대한 체크를 추가해야 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction getStickSetting(controls: CockpitControls) {\n  const { leftSideStick, rightSideStick } = controls;\n  if(leftSideStick === 0) {\n    return rightSideStick;\n  } else if(rightSideStick === 0) {\n    return leftSideStick;\n  }\n  // ???\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e두 스틱이 모두 중립이 아닌 경우를 고려해 보자. 다행히 두 스틱이 비슷한 값이라면 스틱의 각도를 평균해서 계산할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003e// 둘 다 중립이 아니지만, 각도가 비슷할 때\nfunction getStickSetting(controls: CockpitControls) {\n  const { leftSideStick, rightSideStick } = controls;\n  if(leftSideStick === 0) {\n    return rightSideStick;\n  } else if(rightSideStick === 0) {\n    return leftSideStick;\n  }\n  if(Math.abs(leftSideStick - rightSideStick) \u0026#x3C; 5) {\n    return (leftSideStick + rightSideStick) / 2;\n  }\n  // ???\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e그러나 두 스틱의 각도가 매우 다른 경우는 해결하기 어렵다. 그럼에도 비행 중이기 스틱의 각도는 어떻게든 설정되어야 한다.\u003c/p\u003e\n\u003chr\u003e\n\u003cp\u003e한편, 에어버스의 사고 당시 로직은 이러했다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction getStickSetting(controls: CockpitControls) {\n  return (controls.leftSideStick + controls.rightSideStick) / 2;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e기장이 스틱을 앞으로 밀었음에도 부기장이 뒤로 당기고 있었기에 평균값에는 변화가 없었던 것이다. 따라서 에어버스는 아무것도 하지 않은 것이 된다.\u003c/p\u003e\n\u003cp\u003e이 모든 이야기의 요점은, 주어진 입력으로 \u003ccode\u003egetStickSetting\u003c/code\u003e을 구현하는 제대로 된 방법이 없다는 것이다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003egetStickSetting은 실패할 수밖에 없었다.\u003c/code\u003e\u003c/p\u003e\n\u003cp\u003e대부분의 비행기는 두 개의 스틱이 기계적으로 연결되어 있다. 부기장이 뒤로 당기면, 기장의 스틱도 뒤로 당겨진다.\u003c/p\u003e\n\u003cp\u003e기계적으로 연결된 스틱의 상태는 표현이 간단하다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einterface CockpitControls {\n  stickAngle: number;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e사실 getStickSetting 함수는 전혀 필요 없었다.\u003c/p\u003e\n\u003cp\u003e타입을 설계할 때는 어떤 값들을 포함하고 어떤 값들을 제외할지 신중하게 생각해야 한다.\u003c/p\u003e\n\u003cp\u003e유효한 상태를 표현하는 값만 허용한다면 코드를 작성하기 쉬워지고 타입 체크가 용이해진다.\u003c/p\u003e\n\u003cp\u003e유효한 상태만 허용하는 것은 매우 일반적인 원칙이다.\u003c/p\u003e\n\u003chr\u003e\n\u003cul\u003e\n\u003cli\u003e유효한 상태와 무효한 상태를 둘 다 표현하는 타입은 혼란을 초래하기 쉽고 오류를 유발하게 된다.\u003c/li\u003e\n\u003cli\u003e유효한 상태만 표현하는 타입을 지향해야 한다. 코드가 길어지거나 표현하기 어렵지만 결국은 시간을 절약하고 고통을 줄일 수 있다.\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/blog/post/[realSlug]","query":{"realSlug":"1"},"buildId":"Vn2MyYZs1JmGR9bFd08uD","assetPrefix":"/https://king-bada.dev","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>