<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><title>킹왕짱바다 - 블로그</title><meta name="viewport" content="width=device-width, initial-scale=1"/><meta name="description" content="블로그. 공부 내용, 일상을 자유롭게 기록."/><meta name="keyword" content="장현광, 킹왕짱바다, 웹, 개발, 개발자, 개발자 블로그, 일상, 잡담, 공부, 취미, 기록"/><meta name="robots" content="index, follow"/><meta property="og:type" content="website"/><meta property="og:title" content="킹왕짱바다 - 블로그"/><meta property="og:description" content="블로그. 자유롭고 잡다한 기록들."/><meta property="og:image" content="../assets/images/me_1.png"/><meta property="og:image:width" content="630"/><meta property="og:image:height" content="630"/><meta property="og:url" content="/blog/2"/><meta property="twitter:card" content="summary"/><meta property="twitter:title" content="킹왕짱바다 - 블로그"/><meta property="twitter:description" content="블로그. 자유롭고 잡다한 기록들."/><meta property="twitter:image" content="../assets/images/me_1.png"/><meta name="next-head-count" content="17"/><meta charSet="utf-8"/><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"/><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"/><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"/><link rel="manifest" href="/site.webmanifest"/><link rel="preload" href="/https://king-bada.dev/_next/static/css/52f7012b3b79f2fb.css" as="style"/><link rel="stylesheet" href="/https://king-bada.dev/_next/static/css/52f7012b3b79f2fb.css" data-n-g=""/><noscript data-n-css=""></noscript><script defer="" nomodule="" src="/https://king-bada.dev/_next/static/chunks/polyfills-c67a75d1b6f99dc8.js"></script><script src="/https://king-bada.dev/_next/static/chunks/webpack-bb1962c799383232.js" defer=""></script><script src="/https://king-bada.dev/_next/static/chunks/framework-df7ee52d1c137bc3.js" defer=""></script><script src="/https://king-bada.dev/_next/static/chunks/main-d1841ffbf0c00f48.js" defer=""></script><script src="/https://king-bada.dev/_next/static/chunks/pages/_app-0101e8f78d66ce0d.js" defer=""></script><script src="/https://king-bada.dev/_next/static/chunks/453-875485057ff901bb.js" defer=""></script><script src="/https://king-bada.dev/_next/static/chunks/830-744088323c11a854.js" defer=""></script><script src="/https://king-bada.dev/_next/static/chunks/pages/blog/post/%5BrealSlug%5D-305dede71629126c.js" defer=""></script><script src="/https://king-bada.dev/_next/static/Vn2MyYZs1JmGR9bFd08uD/_buildManifest.js" defer=""></script><script src="/https://king-bada.dev/_next/static/Vn2MyYZs1JmGR9bFd08uD/_ssgManifest.js" defer=""></script></head><body><div id="__next"><header class="wrapper"><div class="my-8 p-16 bg-white border-4 border-blue-500 rounded font-oswald font-bold shadow-normal"><h1 class="mt-0 mb-4 text-7xl text-blue-500 font-normal">아이템 24: 일관성 있는 별칭 사용하기</h1><span class="block mb-12 text-base text-blue-500">2023-02-11</span><ul class="flex gap-2 m-0 p-0"><li class=" inline-flex justify-center items-center py-1 px-2 bg-blue-300 rounded font-notoSans font-normal text-xs cursor-pointer hover:bg-blue-400 ">Typescript</li><li class=" inline-flex justify-center items-center py-1 px-2 bg-blue-300 rounded font-notoSans font-normal text-xs cursor-pointer hover:bg-blue-400 ">Javascript</li></ul></div></header><nav class="wrapper flex justify-between items-center sticky top-[-1px] z-50 w-full mx-auto py-4 px-6 bg-blue-500 text-white transition-all duration-700 east-in-out"><a class="text-inherit no-underline hover:text-orange-400" href="/">바다</a><ul></ul><a class="text-inherit no-underline py-2 px-6 bg-orange-400 hover:bg-orange-400/80 rounded-full" href="/info/">Contact</a></nav><div class="wrapper"><main class="py-8"><article class="post-container"><h1>아이템 24: 일관성 있는 별칭 사용하기</h1>
<pre><code>const borough = {
  name: 'Brooklyn',
  location: [40.688, -73.979]
};
const loc = borough.location;
</code></pre>
<p>위 코드에서 <code>borough.location</code> 배열에 <code>loc</code> 이라는 <code>별칭(alias)</code>을 만들었다.</p>
<p>별칭의 값을 변경하면 원래 속성값에서도 변경된다.</p>
<p>허나, 별칭을 남발해서 사용하면 제어 흐름을 분석하기 어렵다.</p>
<p>타입스크립트에서도 별칭을 신중하게 사용해야 한다.</p>
<p>다각형을 표현하는 자료구조를 가정해 보자.</p>
<pre><code>interface Coordinate {
  x: number;
  y: number;
}

interface BoundingBox {
  x: [number, number];
  y: [number, number];
}

interface Polygon {
  exterior: Coordinate[];
  holes: Coordinate[][];
  bbox?: BoundingBox;
}
</code></pre>
<p>다각형의 기하학적 구조는 <code>exterior</code>와 <code>holes</code> 속성으로 정의된다. <code>bbox</code>는 필수가 아닌 최적화 속성이다.</p>
<p><code>bbox</code> 속성을 사용하면 어떤 점이 다각형에 포함되는지 빠르게 체크할 수 있다.</p>
<pre><code>function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  if(polygon.bbox) {
    if(pt.x &#x3C; polygon.bbox.x[0] || pt.x > polygon.bbox.x[1] ||
      pt.y &#x3C; polygon.bbox.y[0] || pt.y > polygon.bbox.y[1]) {
      return false;
    }
  }

  // ...
}
</code></pre>
<p>위 코드는 잘 작동하지만(타입체크도 통과) 반복되는 부분이 존재한다.</p>
<p><code>polygon.bbox</code>는 3줄에 걸쳐 5번이나 등장한다. 아래는 중복을 줄이기 위해 임시 변수를 뽑아낸 모습이다.</p>
<pre><code>function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox;
  if(polygon.bbox) {
    if(pt.x &#x3C; box.x[0] || pt.x > box.x[1] || // box 객체가 'undefined'일 수 있습니다.
      pt.y &#x3C; box.y[0] || pt.y > box.y[1]) {
      return false;
    }
  }

  // ...
}
</code></pre>
<p>(strictNullChecks를 화성화했다고 가정)</p>
<p>위 코드는 동작하지만 편집기에서 오류로 표시된다. <code>polygon.bbox</code>라는 별도의  <code>box</code>라는 별칭을 만들었고, 첫 번째에서 잘 동작했던 제어 흐름 분석을 방해했기 때문이다.</p>
<p><code>polygon.bbox</code>는 타입이 <code>BoundingBox | undefined</code>인데 속성 체크가 <code>polygon.bbox</code>의 타입을 정제했지만 <code>box</code>는 끄렇지 않았기 때문에 오류가 발생한다.</p>
<p>이러한 오류는 <code>별칭은 일관성 있게 사용한다</code>는 기본 원칙(golden rule)을 지키면 방지할 수 있다.</p>
<pre><code>function isPointInPolygon(polygon: Polygon, pt: Coordinate) {
  const box = polygon.bbox;
  if(box) {
    if(pt.x &#x3C; box.x[0] || pt.x > box.x[1] ||
      pt.y &#x3C; box.y[0] || pt.y > box.y[1]) {
      return false;
    }
  }

  // ...
}
</code></pre>
<hr>
<p>그러나 객체 비구조화를 이용할 때는 두 가지를 주의해야 한다.</p>
<ul>
<li>전체 <code>bbox</code> 속성이 아니라 <code>x</code>와 <code>y</code>가 선택적 속성일 경우에 속성 체크가 더 필요하다. 따라서 타입의 경계에 <code>null</code> 값을 추가하는 것이 좋다(아이템 31).</li>
<li><code>bbox</code>에는 선택적 속성이 적합했지만 <code>holes</code>는 그렇지 않다. <code>holes</code>가 선택적이라면, 값이 없거나 빈 배열이었을 것이다. 차이가 없는데 이름을 구별한것이다. 빈 배열은 <code>holes 없음</code>을 나타내는 좋은 방법이다.</li>
</ul>
<p>별칭은 타입 체커뿐만 아니라 런타임에도 혼동을 야기할 수 있다.</p>
<pre><code>const { bbox } = polygon;
if(!bbox) {
  calculatePolygonBbox(polygon);  // polygon.bbox가 채워진다.
  // 이제 polygon.bbox와 bbox는 다른 값을 참조한다.
}
</code></pre>
<p>타입스크립트의 제어 흐름 분석은 지역 변수에는 꽤 잘 작동한다. 그러나 객체 속성에서는 주의해야 한다.</p>
<pre><code>function fn(p: Polygon) { /* ... */ }

polygon.bbox. // 타입이 BoundingBox | undefined
if(polygon.bbox) {
  polygon.bbox. // 타입이 BoundingBox
  fn(polygon);
  polygon.bbox. // 타입이 BoundingBox
}
</code></pre>
<p><code>fn(polygon)</code> 호출은 <code>polygon.bbox</code>를 제거할 가능성이 있으므로 타입을 <code>BoundingBox | undefined</code>로 되돌리는 것이 안절한 것이다. 그러나 함수를 호출할 때마다 속성체크를 반복해야 하기 때문에 좋지 않다. 그래서 타입스크립트는 함수가 타입 정제를 무효화하지 않느다고 가정한다. 그러나 실제로는 무효화될 가능성이 있다.</p>
<p><code>polygon.bbox</code>로 사용하는 대신 <code>bbox</code> 지역 변수로 뽑아내서 사용하면 <code>bbox</code>의 타입은 정확히 유지되지만, <code>polygon.bbox</code>의 값과 같게 유지되지 않을 수 있다.</p>
<h3>요약</h3>
<ul>
<li>별칭은 타입스크립트가 타입을 좁히는 것을 방해한다. 따라서 변수에 별칭을 사용할 때는 일관되게 사용해야 한다.</li>
<li>비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋다.</li>
<li>함수 호출이 객체 속성의 타입 정제를 무효화할 수 있다는 점을 주의해야 한다. 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.</li>
</ul>
</article></main></div><footer class="py-16 bg-slate-800"><div class="wrapper"><h1 class="mb-2 text-lg text-white font-bold italic">킹왕짱바다</h1><div class="flex flex-row text-white"><div class="flex flex-col w-16"><span class="flex justify-between"><span>이</span><span>름</span></span><span class="flex justify-between"><span>이</span><span>메</span><span>일</span></span></div><div class="flex flex-col mx-1"><span>:</span><span>:</span></div><div class="flex flex-col"><span>장현광</span><span>wkdgusrhkd@gmail.com</span></div></div><h2 class="mt-2 text-base text-white">© Created by King-Bada, 2023.</h2></div></footer></div><script id="__NEXT_DATA__" type="application/json">{"props":{"pageProps":{"post":{"slug":"2","id":2,"title":"아이템 24: 일관성 있는 별칭 사용하기","date":"2023-02-11","tags":["Typescript","Javascript"],"summary":"일관성 있는 별칭을 사용해야 합니다.","content":"\u003ch1\u003e아이템 24: 일관성 있는 별칭 사용하기\u003c/h1\u003e\n\u003cpre\u003e\u003ccode\u003econst borough = {\n  name: 'Brooklyn',\n  location: [40.688, -73.979]\n};\nconst loc = borough.location;\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드에서 \u003ccode\u003eborough.location\u003c/code\u003e 배열에 \u003ccode\u003eloc\u003c/code\u003e 이라는 \u003ccode\u003e별칭(alias)\u003c/code\u003e을 만들었다.\u003c/p\u003e\n\u003cp\u003e별칭의 값을 변경하면 원래 속성값에서도 변경된다.\u003c/p\u003e\n\u003cp\u003e허나, 별칭을 남발해서 사용하면 제어 흐름을 분석하기 어렵다.\u003c/p\u003e\n\u003cp\u003e타입스크립트에서도 별칭을 신중하게 사용해야 한다.\u003c/p\u003e\n\u003cp\u003e다각형을 표현하는 자료구조를 가정해 보자.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003einterface Coordinate {\n  x: number;\n  y: number;\n}\n\ninterface BoundingBox {\n  x: [number, number];\n  y: [number, number];\n}\n\ninterface Polygon {\n  exterior: Coordinate[];\n  holes: Coordinate[][];\n  bbox?: BoundingBox;\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e다각형의 기하학적 구조는 \u003ccode\u003eexterior\u003c/code\u003e와 \u003ccode\u003eholes\u003c/code\u003e 속성으로 정의된다. \u003ccode\u003ebbox\u003c/code\u003e는 필수가 아닌 최적화 속성이다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003ebbox\u003c/code\u003e 속성을 사용하면 어떤 점이 다각형에 포함되는지 빠르게 체크할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction isPointInPolygon(polygon: Polygon, pt: Coordinate) {\n  if(polygon.bbox) {\n    if(pt.x \u0026#x3C; polygon.bbox.x[0] || pt.x \u003e polygon.bbox.x[1] ||\n      pt.y \u0026#x3C; polygon.bbox.y[0] || pt.y \u003e polygon.bbox.y[1]) {\n      return false;\n    }\n  }\n\n  // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e위 코드는 잘 작동하지만(타입체크도 통과) 반복되는 부분이 존재한다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epolygon.bbox\u003c/code\u003e는 3줄에 걸쳐 5번이나 등장한다. 아래는 중복을 줄이기 위해 임시 변수를 뽑아낸 모습이다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction isPointInPolygon(polygon: Polygon, pt: Coordinate) {\n  const box = polygon.bbox;\n  if(polygon.bbox) {\n    if(pt.x \u0026#x3C; box.x[0] || pt.x \u003e box.x[1] || // box 객체가 'undefined'일 수 있습니다.\n      pt.y \u0026#x3C; box.y[0] || pt.y \u003e box.y[1]) {\n      return false;\n    }\n  }\n\n  // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e(strictNullChecks를 화성화했다고 가정)\u003c/p\u003e\n\u003cp\u003e위 코드는 동작하지만 편집기에서 오류로 표시된다. \u003ccode\u003epolygon.bbox\u003c/code\u003e라는 별도의  \u003ccode\u003ebox\u003c/code\u003e라는 별칭을 만들었고, 첫 번째에서 잘 동작했던 제어 흐름 분석을 방해했기 때문이다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epolygon.bbox\u003c/code\u003e는 타입이 \u003ccode\u003eBoundingBox | undefined\u003c/code\u003e인데 속성 체크가 \u003ccode\u003epolygon.bbox\u003c/code\u003e의 타입을 정제했지만 \u003ccode\u003ebox\u003c/code\u003e는 끄렇지 않았기 때문에 오류가 발생한다.\u003c/p\u003e\n\u003cp\u003e이러한 오류는 \u003ccode\u003e별칭은 일관성 있게 사용한다\u003c/code\u003e는 기본 원칙(golden rule)을 지키면 방지할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction isPointInPolygon(polygon: Polygon, pt: Coordinate) {\n  const box = polygon.bbox;\n  if(box) {\n    if(pt.x \u0026#x3C; box.x[0] || pt.x \u003e box.x[1] ||\n      pt.y \u0026#x3C; box.y[0] || pt.y \u003e box.y[1]) {\n      return false;\n    }\n  }\n\n  // ...\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003chr\u003e\n\u003cp\u003e그러나 객체 비구조화를 이용할 때는 두 가지를 주의해야 한다.\u003c/p\u003e\n\u003cul\u003e\n\u003cli\u003e전체 \u003ccode\u003ebbox\u003c/code\u003e 속성이 아니라 \u003ccode\u003ex\u003c/code\u003e와 \u003ccode\u003ey\u003c/code\u003e가 선택적 속성일 경우에 속성 체크가 더 필요하다. 따라서 타입의 경계에 \u003ccode\u003enull\u003c/code\u003e 값을 추가하는 것이 좋다(아이템 31).\u003c/li\u003e\n\u003cli\u003e\u003ccode\u003ebbox\u003c/code\u003e에는 선택적 속성이 적합했지만 \u003ccode\u003eholes\u003c/code\u003e는 그렇지 않다. \u003ccode\u003eholes\u003c/code\u003e가 선택적이라면, 값이 없거나 빈 배열이었을 것이다. 차이가 없는데 이름을 구별한것이다. 빈 배열은 \u003ccode\u003eholes 없음\u003c/code\u003e을 나타내는 좋은 방법이다.\u003c/li\u003e\n\u003c/ul\u003e\n\u003cp\u003e별칭은 타입 체커뿐만 아니라 런타임에도 혼동을 야기할 수 있다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003econst { bbox } = polygon;\nif(!bbox) {\n  calculatePolygonBbox(polygon);  // polygon.bbox가 채워진다.\n  // 이제 polygon.bbox와 bbox는 다른 값을 참조한다.\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e타입스크립트의 제어 흐름 분석은 지역 변수에는 꽤 잘 작동한다. 그러나 객체 속성에서는 주의해야 한다.\u003c/p\u003e\n\u003cpre\u003e\u003ccode\u003efunction fn(p: Polygon) { /* ... */ }\n\npolygon.bbox. // 타입이 BoundingBox | undefined\nif(polygon.bbox) {\n  polygon.bbox. // 타입이 BoundingBox\n  fn(polygon);\n  polygon.bbox. // 타입이 BoundingBox\n}\n\u003c/code\u003e\u003c/pre\u003e\n\u003cp\u003e\u003ccode\u003efn(polygon)\u003c/code\u003e 호출은 \u003ccode\u003epolygon.bbox\u003c/code\u003e를 제거할 가능성이 있으므로 타입을 \u003ccode\u003eBoundingBox | undefined\u003c/code\u003e로 되돌리는 것이 안절한 것이다. 그러나 함수를 호출할 때마다 속성체크를 반복해야 하기 때문에 좋지 않다. 그래서 타입스크립트는 함수가 타입 정제를 무효화하지 않느다고 가정한다. 그러나 실제로는 무효화될 가능성이 있다.\u003c/p\u003e\n\u003cp\u003e\u003ccode\u003epolygon.bbox\u003c/code\u003e로 사용하는 대신 \u003ccode\u003ebbox\u003c/code\u003e 지역 변수로 뽑아내서 사용하면 \u003ccode\u003ebbox\u003c/code\u003e의 타입은 정확히 유지되지만, \u003ccode\u003epolygon.bbox\u003c/code\u003e의 값과 같게 유지되지 않을 수 있다.\u003c/p\u003e\n\u003ch3\u003e요약\u003c/h3\u003e\n\u003cul\u003e\n\u003cli\u003e별칭은 타입스크립트가 타입을 좁히는 것을 방해한다. 따라서 변수에 별칭을 사용할 때는 일관되게 사용해야 한다.\u003c/li\u003e\n\u003cli\u003e비구조화 문법을 사용해서 일관된 이름을 사용하는 것이 좋다.\u003c/li\u003e\n\u003cli\u003e함수 호출이 객체 속성의 타입 정제를 무효화할 수 있다는 점을 주의해야 한다. 속성보다 지역 변수를 사용하면 타입 정제를 믿을 수 있다.\u003c/li\u003e\n\u003c/ul\u003e\n"}},"__N_SSG":true},"page":"/blog/post/[realSlug]","query":{"realSlug":"2"},"buildId":"Vn2MyYZs1JmGR9bFd08uD","assetPrefix":"/https://king-bada.dev","isFallback":false,"gsp":true,"scriptLoader":[]}</script></body></html>